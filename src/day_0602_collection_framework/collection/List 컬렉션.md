# List 컬렉션

* 객체를 일렬로 늘어놓은 구조를 갖고있다
* __순서를 유지하고 저장__
* __객체를 인덱스로 관리-> 객체를 저장하면 자동 인덱스가 부여됨__ -> 인덱스로 객체를 검색,삭제
* 중복저장이 가능하다

## ArrayList

* List 인터페이스의 구현 클래스

* 배열과 유사

* 저장용량을 초과한 객체들이 들어오면 자동적으로 저장용량이 늘어남

  * ```java
    List<E> list = new ArrayList<E>();//E:타입 파라미터
    ```

  * 생성자로 용량의 크기를 정할 수 있음 (new ArrayList<E>(30);)

  * 기본 생성자로 객체 생성시 초기용량 개수 :  __10개__

* 인덱스 0 부터 차례대로 저장
* 특정 인덱스의 객체를 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨짐
  * 특정 인덱스에 객체를 삽입하면 해당 인덱스부터 마지막 인덱스까지 모두 1씩 밀려남

* 빈번한 객체삭제와 삽입: LinkedList 가 유리
* 인덱스 검색과 배열의 맨뒤에 값을 삽입하는 경우: ArrayList가 유리

* 고정된 객체들로 구성된 List를 생성할 때

  * Arrays.asList(T...a)메소드를 사용

  * ```java
    List<String> array = Arrays.asList("홍길동","이순신","신사임당");
    ```

## Vector

```java
List<E> list = new Vector<E>();
```

* ArrayList와 비슷
* 동기화된 메소드로 구성됨
  * 멀티 스레드가 동시에 이 메소드들을 실행할 수 없음
  * 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다
    *  멀티 스레드 환경에서 안전하게 객체을 추가,삭제할 수 있다

## LinkedList

```java
List<E> list = new LinkedList<E>();
```

* 처음 생성될 때는 어떠한 링크도 만들어지지 않기 때문에 내부는 비어있음

* ArrayList와 사용방법은 똑같지만 내부구조는 완전 다름
* 인접 참조를 링크해서 체인처럼 관리함

